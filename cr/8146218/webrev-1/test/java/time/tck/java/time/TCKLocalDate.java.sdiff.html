<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff test/java/time/tck/java/time </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/java.base/share/classes/java/time/LocalDate.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> next &gt</center>
<h2>test/java/time/tck/java/time/TCKLocalDate.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 102 import java.time.ZoneOffset;
 103 import java.time.ZonedDateTime;
 104 import java.time.chrono.IsoChronology;
 105 import java.time.chrono.IsoEra;
 106 import java.time.format.DateTimeFormatter;
 107 import java.time.format.DateTimeParseException;
 108 import java.time.temporal.ChronoField;
 109 import java.time.temporal.ChronoUnit;
 110 import java.time.temporal.JulianFields;
 111 import java.time.temporal.Temporal;
 112 import java.time.temporal.TemporalAccessor;
 113 import java.time.temporal.TemporalAdjuster;
 114 import java.time.temporal.TemporalField;
 115 import java.time.temporal.TemporalQueries;
 116 import java.time.temporal.TemporalQuery;
 117 import java.time.temporal.TemporalUnit;
 118 import java.time.temporal.UnsupportedTemporalTypeException;
 119 import java.util.ArrayList;
 120 import java.util.Arrays;
 121 import java.util.List;

 122 
 123 import org.testng.annotations.BeforeMethod;
 124 import org.testng.annotations.DataProvider;
 125 import org.testng.annotations.Test;
 126 import test.java.time.MockSimplePeriod;
 127 import test.java.time.temporal.MockFieldNoValue;
 128 
 129 /**
 130  * Test LocalDate.
 131  */
 132 @Test
 133 public class TCKLocalDate extends AbstractDateTimeTest {
 134 
 135     private static final ZoneOffset OFFSET_PONE = ZoneOffset.ofHours(1);
 136     private static final ZoneOffset OFFSET_PTWO = ZoneOffset.ofHours(2);
 137     private static final ZoneOffset OFFSET_MTWO = ZoneOffset.ofHours(-2);
 138     private static final ZoneId ZONE_PARIS = ZoneId.of("Europe/Paris");
 139     private static final ZoneId ZONE_GAZA = ZoneId.of("Asia/Gaza");
 140 
 141     private LocalDate TEST_2007_07_15;

</pre><hr></hr><pre>
2343 
2344     @Test(dataProvider="sampleToString")
2345     public void test_toString(int y, int m, int d, String expected) {
2346         LocalDate t = LocalDate.of(y, m, d);
2347         String str = t.toString();
2348         assertEquals(str, expected);
2349     }
2350 
2351     private LocalDate date(int year, int month, int day) {
2352         return LocalDate.of(year, month, day);
2353     }
2354 
2355     //-----------------------------------------------------------------
2356     // getEra()
2357     // ----------------------------------------------------------------
2358     @Test
2359     public void test_getEra() {
2360         IsoEra isoEra = LocalDate.MAX.getEra();
2361         assertSame(isoEra,IsoEra.CE);
2362         assertSame(LocalDate.MIN.getEra(),IsoEra.BCE);

































































































































































2363     }
2364 }
</pre></td><td><pre>

</pre><hr></hr><pre>
 102 import java.time.ZoneOffset;
 103 import java.time.ZonedDateTime;
 104 import java.time.chrono.IsoChronology;
 105 import java.time.chrono.IsoEra;
 106 import java.time.format.DateTimeFormatter;
 107 import java.time.format.DateTimeParseException;
 108 import java.time.temporal.ChronoField;
 109 import java.time.temporal.ChronoUnit;
 110 import java.time.temporal.JulianFields;
 111 import java.time.temporal.Temporal;
 112 import java.time.temporal.TemporalAccessor;
 113 import java.time.temporal.TemporalAdjuster;
 114 import java.time.temporal.TemporalField;
 115 import java.time.temporal.TemporalQueries;
 116 import java.time.temporal.TemporalQuery;
 117 import java.time.temporal.TemporalUnit;
 118 import java.time.temporal.UnsupportedTemporalTypeException;
 119 import java.util.ArrayList;
 120 import java.util.Arrays;
 121 import java.util.List;
<span class="new"> 122 import java.util.stream.Collectors;</span>
 123 
 124 import org.testng.annotations.BeforeMethod;
 125 import org.testng.annotations.DataProvider;
 126 import org.testng.annotations.Test;
 127 import test.java.time.MockSimplePeriod;
 128 import test.java.time.temporal.MockFieldNoValue;
 129 
 130 /**
 131  * Test LocalDate.
 132  */
 133 @Test
 134 public class TCKLocalDate extends AbstractDateTimeTest {
 135 
 136     private static final ZoneOffset OFFSET_PONE = ZoneOffset.ofHours(1);
 137     private static final ZoneOffset OFFSET_PTWO = ZoneOffset.ofHours(2);
 138     private static final ZoneOffset OFFSET_MTWO = ZoneOffset.ofHours(-2);
 139     private static final ZoneId ZONE_PARIS = ZoneId.of("Europe/Paris");
 140     private static final ZoneId ZONE_GAZA = ZoneId.of("Asia/Gaza");
 141 
 142     private LocalDate TEST_2007_07_15;

</pre><hr></hr><pre>
2344 
2345     @Test(dataProvider="sampleToString")
2346     public void test_toString(int y, int m, int d, String expected) {
2347         LocalDate t = LocalDate.of(y, m, d);
2348         String str = t.toString();
2349         assertEquals(str, expected);
2350     }
2351 
2352     private LocalDate date(int year, int month, int day) {
2353         return LocalDate.of(year, month, day);
2354     }
2355 
2356     //-----------------------------------------------------------------
2357     // getEra()
2358     // ----------------------------------------------------------------
2359     @Test
2360     public void test_getEra() {
2361         IsoEra isoEra = LocalDate.MAX.getEra();
2362         assertSame(isoEra,IsoEra.CE);
2363         assertSame(LocalDate.MIN.getEra(),IsoEra.BCE);
<span class="new">2364     }</span>
<span class="new">2365 </span>
<span class="new">2366     //-----------------------------------------------------------------</span>
<span class="new">2367     // datesUntil()</span>
<span class="new">2368     // ----------------------------------------------------------------</span>
<span class="new">2369     @Test</span>
<span class="new">2370     public void test_datesUntil() {</span>
<span class="new">2371         assertEquals(</span>
<span class="new">2372                 date(2015, 9, 29).datesUntil(date(2015, 10, 3)).collect(</span>
<span class="new">2373                         Collectors.toList()), Arrays.asList(date(2015, 9, 29),</span>
<span class="new">2374                         date(2015, 9, 30), date(2015, 10, 1), date(2015, 10, 2)));</span>
<span class="new">2375         assertEquals(date(2015, 9, 29).datesUntil(date(2015, 10, 3), Period.ofDays(2))</span>
<span class="new">2376                 .collect(Collectors.toList()), Arrays.asList(date(2015, 9, 29),</span>
<span class="new">2377                 date(2015, 10, 1)));</span>
<span class="new">2378         assertEquals(date(2015, 1, 31).datesUntil(date(2015, 6, 1), Period.ofMonths(1))</span>
<span class="new">2379                 .collect(Collectors.toList()), Arrays.asList(date(2015, 1, 31),</span>
<span class="new">2380                 date(2015, 2, 28), date(2015, 3, 31), date(2015, 4, 30),</span>
<span class="new">2381                 date(2015, 5, 31)));</span>
<span class="new">2382     }</span>
<span class="new">2383     </span>
<span class="new">2384     @Test(expectedExceptions=NullPointerException.class)</span>
<span class="new">2385     public void test_datesUntil_nullEnd() {</span>
<span class="new">2386         LocalDate date = date(2015, 1, 31);</span>
<span class="new">2387         date.datesUntil(null);</span>
<span class="new">2388     }</span>
<span class="new">2389     </span>
<span class="new">2390     @Test(expectedExceptions=NullPointerException.class)</span>
<span class="new">2391     public void test_datesUntil_nullEndStep() {</span>
<span class="new">2392         LocalDate date = date(2015, 1, 31);</span>
<span class="new">2393         date.datesUntil(null, Period.ofDays(1));</span>
<span class="new">2394     }</span>
<span class="new">2395     </span>
<span class="new">2396     @Test(expectedExceptions=NullPointerException.class)</span>
<span class="new">2397     public void test_datesUntil_nullStep() {</span>
<span class="new">2398         LocalDate date = date(2015, 1, 31);</span>
<span class="new">2399         date.datesUntil(date, null);</span>
<span class="new">2400     }</span>
<span class="new">2401     </span>
<span class="new">2402     @Test(expectedExceptions=IllegalArgumentException.class)</span>
<span class="new">2403     public void test_datesUntil_zeroStep() {</span>
<span class="new">2404         LocalDate date = date(2015, 1, 31);</span>
<span class="new">2405         date.datesUntil(date, Period.ZERO);</span>
<span class="new">2406     }</span>
<span class="new">2407     </span>
<span class="new">2408     @Test(expectedExceptions=IllegalArgumentException.class)</span>
<span class="new">2409     public void test_datesUntil_negativeStep() {</span>
<span class="new">2410         LocalDate date = date(2015, 1, 31);</span>
<span class="new">2411         date.datesUntil(date, Period.of(1, 0, -1));</span>
<span class="new">2412     }</span>
<span class="new">2413     </span>
<span class="new">2414     @DataProvider(name="datesUntil")</span>
<span class="new">2415     public Object[][] provider_datesUntil() {</span>
<span class="new">2416         return new Object[][] {</span>
<span class="new">2417                 {MIN_DATE, MIN_DATE},</span>
<span class="new">2418                 {MIN_DATE, MAX_DATE},</span>
<span class="new">2419                 {MAX_DATE, MAX_DATE},</span>
<span class="new">2420                 {date(2015,10,1), date(2015,10,2)},</span>
<span class="new">2421                 {date(2015,10,1), date(2015,11,1)},</span>
<span class="new">2422                 {date(2015,10,31), date(2015,11,1)},</span>
<span class="new">2423                 {date(2015,10,1), MAX_DATE},</span>
<span class="new">2424                 {MIN_DATE, date(2015,10,1)}</span>
<span class="new">2425         };</span>
<span class="new">2426     }</span>
<span class="new">2427     </span>
<span class="new">2428     @Test(dataProvider = "datesUntil")</span>
<span class="new">2429     public void test_datesUntil_count(LocalDate start, LocalDate end) {</span>
<span class="new">2430         assertEquals(end.datesUntil(start).count(), 0L);</span>
<span class="new">2431         assertEquals(end.datesUntil(start, Period.ofYears(1)).count(), 0L);</span>
<span class="new">2432         assertEquals(end.datesUntil(start, Period.ofMonths(1)).count(), 0L);</span>
<span class="new">2433         assertEquals(end.datesUntil(start, Period.ofDays(1)).count(), 0L);</span>
<span class="new">2434         assertEquals(start.datesUntil(end).count(), start.until(end, ChronoUnit.DAYS));</span>
<span class="new">2435         assertEquals(start.datesUntil(end, Period.ofDays(1)).count(),</span>
<span class="new">2436                 start.until(end, ChronoUnit.DAYS));</span>
<span class="new">2437     }</span>
<span class="new">2438     </span>
<span class="new">2439     @DataProvider(name="datesUntilSteps")</span>
<span class="new">2440     public Object[][] provider_datesUntil_steps() {</span>
<span class="new">2441         List&lt;Object[]&gt; data = new ArrayList&lt;&gt;(Arrays.asList(new Object[][] {</span>
<span class="new">2442             {MIN_DATE, MAX_DATE, Period.ofYears(Year.MAX_VALUE)},</span>
<span class="new">2443             {MIN_DATE, MAX_DATE, Period.ofDays(2)},</span>
<span class="new">2444             {MIN_DATE, MAX_DATE, Period.of(1,2,3)},</span>
<span class="new">2445             {MIN_DATE, MAX_DATE, Period.of(1,2,1000000)},</span>
<span class="new">2446             {MIN_DATE, MAX_DATE, Period.of(1,1000000,3)},</span>
<span class="new">2447             {MIN_DATE, MAX_DATE, Period.of(1000000,2,3)},</span>
<span class="new">2448             {MIN_DATE, MAX_DATE.minusYears(1), Period.ofYears(Year.MAX_VALUE)},</span>
<span class="new">2449             {MAX_DATE.minusMonths(1), MAX_DATE, Period.ofMonths(1)},</span>
<span class="new">2450             {date(Year.MAX_VALUE, 2, 20), MAX_DATE, Period.of(0, 1, 1)},</span>
<span class="new">2451             {date(2015,1,1), date(2016,1,1), Period.ofYears(1)},</span>
<span class="new">2452             {date(2015,1,1), date(2016,1,1), Period.ofDays(365)},</span>
<span class="new">2453             {date(2015,1,1), date(2016,1,1), Period.ofDays(366)},</span>
<span class="new">2454             {date(2015,1,1), date(2016,1,1), Period.ofDays(4)},</span>
<span class="new">2455             {date(2015,1,1), date(2016,1,1), Period.of(0,1,2)},</span>
<span class="new">2456             {date(2015,1,1), date(2016,1,1), Period.ofMonths(1)},</span>
<span class="new">2457             {date(2015,1,1), date(2016,1,1), Period.ofMonths(12)},</span>
<span class="new">2458             {date(2015,1,1), date(2016,1,2), Period.ofMonths(12)},</span>
<span class="new">2459             {date(2015,1,1), date(2016,1,1), Period.of(0, 11, 30)},</span>
<span class="new">2460             {date(2015,1,1), date(2015,12,31), Period.of(0, 11, 30)},</span>
<span class="new">2461             {date(2015,1,31), date(2015,12,31), Period.ofMonths(2)},</span>
<span class="new">2462             {date(2015,1,31), date(2015,12,1), Period.ofMonths(2)},</span>
<span class="new">2463             {date(2015,1,31), date(2015,11,30), Period.ofMonths(2)},</span>
<span class="new">2464             {date(2015,1,31), date(2030,11,30), Period.of(1,30,365)},</span>
<span class="new">2465             {date(2015,1,31), date(2043,1,31), Period.of(4,0,0)},</span>
<span class="new">2466             {date(2015,1,31), date(2043,2,1), Period.of(4,0,0)},</span>
<span class="new">2467             {date(2015,1,31), date(2043,1,31), Period.of(3,11,30)},</span>
<span class="new">2468             {date(2015,1,31), date(2043,2,1), Period.of(3,11,30)},</span>
<span class="new">2469             {date(2015,1,31), date(2043,1,31), Period.of(0,0,1460)},</span>
<span class="new">2470             {date(2015,1,31), date(2043,1,31), Period.of(0,0,1461)},</span>
<span class="new">2471             {date(2015,1,31), date(2043,2,1), Period.of(0,0,1461)},</span>
<span class="new">2472             {date(2015,1,31), MAX_DATE, Period.of(10,100,1000)},</span>
<span class="new">2473             {date(2015,1,31), MAX_DATE, Period.of(1000000,10000,100000)},</span>
<span class="new">2474             {date(2015,1,31), MAX_DATE, Period.ofDays(10000000)},</span>
<span class="new">2475             {date(2015,1,31), MAX_DATE, Period.ofDays(Integer.MAX_VALUE)},</span>
<span class="new">2476             {date(2015,1,31), MAX_DATE, Period.ofMonths(Integer.MAX_VALUE)},</span>
<span class="new">2477             {date(2015,1,31), MAX_DATE, Period.ofYears(Integer.MAX_VALUE)}</span>
<span class="new">2478         }));</span>
<span class="new">2479         LocalDate start = date(2014, 1, 15);</span>
<span class="new">2480         LocalDate end = date(2015, 3, 4);</span>
<span class="new">2481         for (int months : new int[] { 0, 1, 2, 6, 12, 13 }) {</span>
<span class="new">2482             for (int days = 0; days &lt; 80; days++) {</span>
<span class="new">2483                 if (months &gt; 0 || days &gt; 0)</span>
<span class="new">2484                     data.add(new Object[] { start, end, Period.of(0, months, days) });</span>
<span class="new">2485             }</span>
<span class="new">2486         }</span>
<span class="new">2487         for (int days = 27; days &lt; 100; days++) {</span>
<span class="new">2488             data.add(new Object[] { start, start.plusDays(days), Period.ofMonths(1) });</span>
<span class="new">2489         }</span>
<span class="new">2490         return data.toArray(new Object[data.size()][]);</span>
<span class="new">2491     }</span>
<span class="new">2492 </span>
<span class="new">2493     @Test(dataProvider="datesUntilSteps")</span>
<span class="new">2494     public void test_datesUntil_step(LocalDate start, LocalDate end, Period step) {</span>
<span class="new">2495         // Reverse range: must produce empty stream</span>
<span class="new">2496         assertEquals(end.datesUntil(start, step).count(), 0);</span>
<span class="new">2497         long count = start.datesUntil(end, step).count();</span>
<span class="new">2498         if(start.equals(end)) {</span>
<span class="new">2499             assertTrue(count == 0);</span>
<span class="new">2500         } else {</span>
<span class="new">2501             assertTrue(count &gt; 0);</span>
<span class="new">2502             // the last value must be before the end date</span>
<span class="new">2503             assertTrue(start.plusMonths(step.toTotalMonths()*(count-1))</span>
<span class="new">2504                 .plusDays(step.getDays()*(count-1)).isBefore(end));</span>
<span class="new">2505             try {</span>
<span class="new">2506                 // the next after the last value must be either invalid </span>
<span class="new">2507                 // or not before the end date</span>
<span class="new">2508                 assertFalse(start.plusMonths(step.toTotalMonths()*count)</span>
<span class="new">2509                     .plusDays(step.getDays()*count).isBefore(end));</span>
<span class="new">2510             } catch (ArithmeticException | DateTimeException e) {</span>
<span class="new">2511                 // ignore: possible overflow for the next value is ok</span>
<span class="new">2512             }</span>
<span class="new">2513             if(count &lt; 1000) {</span>
<span class="new">2514                 assertTrue(start.datesUntil(end, step)</span>
<span class="new">2515                     .allMatch(date -&gt; !date.isBefore(start) &amp;&amp; date.isBefore(end)));</span>
<span class="new">2516                 List&lt;LocalDate&gt; list = new ArrayList&lt;&gt;();</span>
<span class="new">2517                 for(long i=0; i&lt;count; i++) {</span>
<span class="new">2518                     list.add(start.plusMonths(step.toTotalMonths()*i)</span>
<span class="new">2519                         .plusDays(step.getDays()*i));</span>
<span class="new">2520                 }</span>
<span class="new">2521                 assertEquals(start.datesUntil(end, step)</span>
<span class="new">2522                     .collect(Collectors.toList()), list);</span>
<span class="new">2523             }</span>
<span class="new">2524         }</span>
2525     }
2526 }
</pre></td>
</tr></table>
<center><a href='../../../../../../src/java.base/share/classes/java/time/LocalDate.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> next &gt</center>
</body></html>
